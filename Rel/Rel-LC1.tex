\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{amsmath}

\usepackage{graphicx,url}
\usepackage{bussproofs}
\EnableBpAbbreviations

\usepackage{indentfirst}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{Relatório Final - Lógica Computacional 1\inst{1}}

\author{Marcelo Araújo - (150016794), Augusto Brandão - (160024366), Ian Nery - (150129670) }


\address{Departamento de Ciência da Computação -- Universidade de Brasília (UNB)}

\begin{document} 

\maketitle

\section*{Introdução}
A lógica computacional, extenso campo de pesquisa e aplicações práticas, é primordialmente utilizada para a comprovação do funcionamento de sistemas críticos hodiernos, que a torna essencial tanto como especialização na área, quanto como introdução para outros âmbitos de pesquisa, como a de inteligência artificial. O objetivo do projeto em questão é principalmente introduzir os alunos a ferramentas de verificação e formalização para a melhor absorção e entendimento das técnicas de manipulação lógica apresentadas em sala, além de demonstrar como tais conceitos aprendidos são aplicados na prática.

No projeto contido nesse relatório, é apresentado para a prova questões sobre propriedades envolvendo a inserção e ordenação de sequências. A ferramenta utilizada para a especificação e verificação formal da lógica por detrás de tais conjecturas é o PVS. O software mencionado é de grande importância para as aplicações práticas descritas acima e outras, como é possível constatar pelo diretório da NASA, que abarca diversas bibliotecas acerca de diversas conjecturas similares a apresentada no trabalho, com a finalidade de auxiliar os pesquisadores da área a ter um entendimento similar ao proposto pelo projeto.
\section*{Explicação das soluções}
\subsection*{Questão 1}
A conjectura da questão 1, {\textit {fs\textunderscore insert\textunderscore in\textunderscore sorted\textunderscore preserves\textunderscore sort}} propõe que para todo s sequência finita e x natural, têm-se que a ordenação de s implica na ordenação de s após uma inserção de x em si. Para o início de sua prova, fora ultilizado um passo de indução forte para a sequência "s" e para a variável "length(s)", sendo essa a variável que define o tamanho da sequência finita "s". A estratégia primordial para a prova de tal conjectura foi a utilização da skolemização e instanciação, relatadas a regras referentes aos quantificadores universais da lógica de Gentzen; manipuladores equacionais com a finalidade de dissecar o problema para torná-lo trivial, como enunciado pelos comandos {\textbf {lift-if}}, {\textbf {replace}} e {\textbf {expand}}; manipuladores lógico-proposicionais, como {\textbf {prop}}; e também comandos com a função de cut, como {\textbf {case}} e {\textbf {lemma}}.
\subsection*{Questão 2}
A questão 2, {\textit {fs\textunderscore insertionsort\textunderscore is\textunderscore sorted}}, é uma conjectura cuja proposição é: para toda sequência finita natural "s" têm-se que a inserção ordenada em "s" torna-se em uma sequência ordenada. Para a prova da conjectura, foi utilizado como na questão 1 a estratégia de indução forte, para as mesmas "s" e "length(s)", e além dos comandos de skolemização e instanciação, foram utilizados novamente os manipuladores equacionais {\textbf {lift-if}}, {\textbf {replace}} e {\textbf {expand}}; o manipulador lógico-proposicional {\textbf {prop}}; e por fim os comandos que exprimem a função cut, nesse caso {\textbf {case}}, {\textbf {rewrite}} e {\textbf {lemma}}.
\subsection*{Questão 3}
A questão 3, {\textit {fs\textunderscore ins\textunderscore and\textunderscore add\textunderscore in\textunderscore perm\textunderscore is\textunderscore perm}}, consiste na proposição que para quaisquer as sequências "s1" e "s2", que são permutações entre si, e para qualquer variável "x", têm que que a inserção de x no primeiro elemento da sequência s1 e a inserção de x dada pelo método {\textit {insertion}} em s2, s1 e s2 ainda são permutações. O método para prova da conjectura foi o uso dos mesmos mecanismos da questão 2, além do comando {\textbf {typepred}}, cuja função é de apresentar restrições de tipo em expressões previamente estabelecidas.
\subsection*{Questão 4}
Já a questão 4, {\textit {fs\textunderscore insertionsort\textunderscore is\textunderscore permutations}}, representa que para cada sequência "s", a inserção ordenada em s e a sequência original s sofrem permutação. Na prova feita, foi utilizado o passo de indução forte como na questão 1, os métodos descritos nas questões 2 e 3, e também o comando de manipulação equacional {\textbf {decompose-equality}}, cuja função é decompor igualdades em componentes mais triviais para prova, como a decomposição de uma igualdade de sequência a separa em uma igualdade de sequências junto a uma igualdade de seus tamanhos.
\section*{Especificação do problema e explicação do método de solução}
	
	Nesta etapa mostraremos o desenvolvimento das provas e suas relações com a dedução natural no cálculo de Gentzen. Omitiremos certos passos com a finalidade de manter a prova legível, como certos comandos de $expand$, passos omitidos serão sinalizados adequadamente quando necessários, além disso, fórmulas escondidas com a mesma finalidade estarão representadas como $\Gamma$ do lado esquedo do sequente e como $\Delta$ do lado direito do sequente.

	\subsection{Questão 1}
	
	Usaremos algumas abreviaçõe com o intuito  de diminuir os tamanhos das provas assim, $s?$ abrevia $is.sorted?(x \ : finseq)$, $i$ abrevia $insertion(x \ : nat, y \ : finseq)$, $l$ abrevia $length(x \ : finseq)$, $s$ abrevia $seq(.)$, $af$ abrevia $addfirst(x \ : nat , y \ : finseq)$.
	
		\begin{prooftree}\label{pr:1.1}
			\AXC{$\nabla_1$}
			\AXC{$\nabla_2$}
			\AXC{$\nabla_3$}
			\RightLabel{$(prop)$}
			\TIC{$\Gamma ,s?(x_1) \Rightarrow \Delta_1$}
			\RightLabel{$(R_{=})$}
			\UIC{$ \Gamma , s?(x_1)\Rightarrow s?(i(x, x_1))$}
			\RightLabel{$(R_{\rightarrow})$}
			\UIC{$\Gamma \Rightarrow s?(x_1) \rightarrow s?(i(x,x_1))$}
			\RightLabel{$(R_{\forall}) \ e \ (LW)$}
			\UIC{$\forall_y \forall_x \ (l(y) < l(x_1)) \rightarrow s?(y) \rightarrow s?(i(x,y)) \Rightarrow \forall_x s?(x_1) \rightarrow s?(i(x,x_1))$}
			\RightLabel{$(mi+)$}
			\UIC{$\Rightarrow \forall_{s, x} \ s?(s) \rightarrow s?(i(x, s))$}
		\end{prooftree}
		
	Onde $\Delta_1$ foi usado para abreviar a igualdade usada por ($R_{=}$), aplicada pelo comando $expand$, as regras de ($R_\forall$) e ($R_\rightarrow$) foram aplicadas com o comando $skeep$.
	
	\begin{equation}
		\begin{split}
		\Delta_1 = IF \ l(x_1) = 0 \ THEN s?(af(x,x_1)) \qquad \qquad\\
		ELSE \ IF \ x \le f(x_1) \ THEN \ s?(af(x,x_1)) \ \ \\
		ELSE \ s?(af(f(x_1), i(x,rest(x_1))) \qquad \qquad
		\end{split}
	\end{equation}
	
	Agora podemos explicar o uso do comando $prop$ em nossa prova para obtermos os ramos $\nabla_{1,2,3}$, a estrutura de $if, then \ else$ pode ser interpretada como uma série de implicações, como no exemplo de $\Delta_1$, temos, $l(x_1) = 0 \rightarrow s?(af(x,x_1))$, como uma primeira implicação, $(\neg{(l(x_1) = 0)} \wedge x \le f(x_1) )\rightarrow s?(af(x,x_1))$, e temos uma terceira implicação que correspode ao caso que nenhuma das duas condições dos $if's$ são verdadeiras,  $(\neg{((l(x_1) = 0) \wedge x \le f(x_1))} )\rightarrow s?(af(x,x_1))$ .
	
	Utilizando o comando $prop$ nessa estrutura obtemos 3 ramos, provenientes da utilização de comandos como $flatten$, $split$ sucetivamente, assim expandindo o $prop$ utilizado acima podemos ver as seguintes provas:
	
	\begin{prooftree}\label{pr:n1}
		\AXC{$\nabla'_1$}
		\UIC{$\Gamma , l(x_1)=0, s?(x_1)\Rightarrow s?(af(x,x_1))$}
		\AXC{$\nabla_2$}
		\AXC{$\nabla_3$}
		\RightLabel{$(prop)$}
		\TIC{$\Gamma ,s?(x_1) \Rightarrow \Delta_1$}
	\end{prooftree}
	
	\begin{prooftree}\label{pr:n2}
		\AXC{$\nabla_1$}
		\AXC{$\nabla'_2$}
		\UIC{$\Gamma , x \le f(x_1), s?(x_1)\Rightarrow s?(af(x,x_1)), \ l(x_1)=0$}
		\AXC{$\nabla_3$}
		\RightLabel{$(prop)$}
		\TIC{$\Gamma ,s?(x_1) \Rightarrow \Delta_1$}
	\end{prooftree}
	
	\begin{prooftree}\label{pr:n3}
		\AXC{$\nabla_1$}
		\AXC{$\nabla_2$}
		\AXC{$\nabla'_3$}
		\UIC{$\Gamma, s?(x_1)\Rightarrow s?(af(x,x_1)), \ l(x_1)=0, x \le f(x_1)$}
		\RightLabel{$(prop)$}
		\TIC{$\Gamma ,s?(x_1) \Rightarrow \Delta_1$}
	\end{prooftree}
	
	Os comando $split$ aplica as regras de $L_\vee$, $R_\wedge$, e $R_\rightarrow$, e o comando $flatten$ as regras de $R_\vee$, $L_\wedge$, e $L_\rightarrow$, e vemos que são essas exatas regras aplicadas aos sequentes da questão em si.
	
	Assim, isso nos dá 3 objetivos para provar, o primeiro representado por $\nabla'_1$, onde queremos provar que para uma sequência $x_1$ de tamanho 0, vazia, a adição de um natural x em uma lista vazia resultam em uma lista ordenada, no caso a lista resultante tera apenas um elemento, estando ordenada, a prova deste ramo pode ser concluída sem maiores dificuldades com os comando apresentados.
	
	Para o $\nabla'_2$ temos o objetivo de provar que para uma lista $x_1$ que está ordenada, com tamanho diferente de 0, a adição de um elemento menor ou igual ao primeiro elemento de $x_1$ no indíce 0 resulta em uma lista ordenada. Podemos ver que se a lista está ordenada e o elemento a ser inserido e menor ou igual ao primeiro de $x_1$ adicioná-lo na primeira posição mantém a ordenação.
	
	\begin{prooftree}
		\AXC{$\nabla_4$}
		\UIC{$\Gamma \Rightarrow  k=0, \Delta $}
		\AXC{$\nabla_5$}
		\UIC{$\Gamma, k=0 \Rightarrow  \Delta $}
		\RightLabel{$(Cut)$}
		\BIC{$\Gamma ,\forall_k k \le l(x_1)-2 \rightarrow x_1.s(k) \le x_1.s(k+1)\Rightarrow af(x,x_1).s(k) \le af(x,x_1).s(k+1), \Delta $}
		\UIC{$\vdots$}
		\UIC{$\Gamma , x \le f(x_1), s?(x_1)\Rightarrow s?(af(x,x_1)), \ l(x_1)=0$}
	\end{prooftree}
	
	Interessante desta prova é a utilização da regra de $Cut$, no caso utilizamos $k=0$, onde $k$ seria o índice de acesso na sequência, assim teremos um ramo provado por $\nabla_5$ que indica que o valor de $k$ é 0 oque nos dá realizando expansões que o primeiro elemento, $af(x,x_1).s(0) \le af(x,x_1).s(1)$, expandindo temos $x \le x_1.s(0)$ do lado direito do sequente, e temos exatamente isso do lado esquerdo também, dentro do $\Gamma$, assim fechamos este ramo.
	
	\begin{equation}
		\Gamma, x \le x_1.s(0) \Rightarrow x \le x_1.s(0), \Delta \quad (Ax)
	\end{equation}
	
	Para $\nabla_4$ temos um quantificador universal a direita, $\forall_k k \le l(x_1)-2 \rightarrow x_1.s(k) \le x_1.s(k+1)$, e agora precisamos usá-lo para provar que os elementos de índice $k$ são menores que $k+1$ com $k$ maior que 0, podemos notar que com esse íncide maior que 1 para a lista nova, $af(x,x_1)$ temos os mesmos elementos da lista $x_1$, que está ordenada, $\Gamma, s?(x_1)$. Utilizamos o comando $inst(``k-1'')$ para remover o quantificador gerado pela definição de is\textunderscore sorted?, $(L_\forall)$. Também temos que remover a implicação presente na fórmula do antecedente, usamos a regra $(L_\rightarrow)$, assim temos mais 2 objetivos para provar, um objetivo provando que o valor de $k$ é valido, e definitivamente que a lista em si está ordenana, como mencionado anteriormente.
	
	\begin{prooftree}
		\AXC{$\nabla_i$}
		\AXC{$\nabla_j$}
		\UIC{$\Gamma, x_1.s(k-1) \le x_1.s(k) \Rightarrow k=0, \ af(x,x_1).s(k) \le af(x,x_1).s(k+1), \Delta $}
		\RightLabel{$L_\rightarrow$}
		\BIC{$\Gamma, (k-1)\le l(x_1)-2 \rightarrow x_1.s(k-1) \le x_1.s(k) \Rightarrow \Delta$}
	\end{prooftree}
			
		\begin{prooftree}
			\AXC{$\nabla'_i$}
			\UIC{$\Gamma, (k-1)\le l(x_1)-2 \Rightarrow k-1 \le l(x_1)-2$}
			\AXC{$\nabla'_j$}
			\RightLabel{$L_\rightarrow$}
			\BIC{$\Gamma, (k-1)\le l(x_1)-2 \rightarrow x_1.s(k-1) \le x_1.s(k) \Rightarrow \Delta$}
		\end{prooftree}
	
	Agora para terminarmos a prova da questão 1 precisamos apenas provar $\nabla'_3$, 
	utilizando a nossa hípotese de indução gerada pelo $measure-induct+$ que estava omitida em $\Gamma$, $\forall_y \forall_x \ (l(y) < l(x_1)) \rightarrow s?(y) \rightarrow s?(i(x,y))$, utilizamos a regra $(L_\forall)$ duas vezes entao teremos:
	
	\begin{prooftree}
		\AXC{$\nabla_6$}
		\UIC{$\Gamma \Rightarrow (l(r(x_1)) < l(x_1)), \Delta$}
		\AXC{$\nabla_7$}
		\UIC{$\Gamma, s?(x_1) \Rightarrow s?(r(x_1))\Delta$}
		\AXC{$\nabla_8$}
		\UIC{$\Gamma, s?(i(x,r(x_1)))\Rightarrow \Delta$}
		\RightLabel{$(L_{\rightarrow})$}
		\TIC{$(l(r(x_1)) < l(x_1)) \rightarrow s?(r(x_1)) \rightarrow s?(i(x,r(x_1)))
			\Rightarrow \Delta$}
		\RightLabel{$(L_\forall)^{2\times}$}
		\UIC{$\Gamma, \forall_y \forall_x \ (l(y) < l(x_1)) \rightarrow s?(y) \rightarrow s?(i(x,y)) \Rightarrow s?(af(f(x,x_1), i(x, r(x_1)))), \Delta$ }
	\end{prooftree}
	
	$\nabla_6$ consiste em provar que o tamanho do resto de $x_1$ é menor que o tamanho de $x_1$, pode ser provado com algumas expansões e o lemaa $empty_seq$, que é a aplicação da regra $(Cut)$.
	
	$\nabla_7$ consiste em provar que se $x_1$ está ordenada o resto de $x_1$ também está.
	
	E então o caso mais complicado, $\nabla_8$ se resume em provar que se o natural $x$ foi inserido em $r(x_1)$ e permaneceu ordenado, a adição do $f(x_1)$ nesta lista inserida mantém a propriedade de ordenada. Utilizamos a regra $Cut$, usando $l(r(x_1) = 0)$, assim temos 2 objetivos, provar que se isto for verdade temos uma lista de 2 elementos $[f(x_1), x]$ está ordenada, como sabemos que $x > f(x_1)$ isso está correto, para o segundo objetivo vai se resumir, com algumas manipulações em provar que $f(x_1) \le f(i(x, r(x_1)))$, assim temos que provar para os casos de $x$ ter sido inserido no primeiro índice do resto de $x_1$, assim teremos $f(x_1) \le x$, e para o caso em que x foi inserido após isso tendo, $f(x_1 \le f(r(x_1)))$, com as inforções que temos de $s?(x_1)$ e $s?(i(x, r(x_1)))$ a prova pode ser concluída fácilmente.
	
	\begin{prooftree}
		\AXC{$\nabla$}
		\UIC{$\Gamma \Rightarrow f(x_1) \le f(i(x, r(x_1))), \Delta$}
		\AXC{$\nabla$}
		\UIC{$\Gamma \Rightarrow f(x_1 \le f(r(x_1))), \Delta$}
		\BIC{$\vdots$}
		\UIC{$\Gamma \Rightarrow l(r(x_1))=0, \Delta$}
		\AXC{$\nabla$}
		\UIC{$\Gamma, l(r(x_1))=0 \Rightarrow \Delta$}
		\RightLabel{$Cut$}
		\BIC{$\Gamma, s?(i(x,r(x_1))), s?(x_1) \Rightarrow s?(af(f(x,x_1), i(x, r(x_1)))), \Delta$}
	\end{prooftree}
	
\section*{Descrição da formalização}

\section*{Conclusões}
A partir da prova lógica das quatro conjecturas auxiliares apresentadas, é possível provar a funcionalidade da função {\textit {fs\textunderscore insertion\textunderscore sort}} empregada como lema no apêndice do trabalho, visto que as questões posteriormente demonstradas são propriedades referentes ao mecanismo de inserção e identificação da ordenação das sequências apresentadas, a prova aplicada da função citada se compõe dos comandos de skolemização da expressão seguida da instanciação do quantificador existencial em variáveis já presentes na expressão sucedida, e então o comando de cut {\textbf{rewrite}} para aplicação dos lemas {\textit {fs\textunderscore insertionsort\textunderscore is\textunderscore sorted}} e {\textit {fs\textunderscore insertion\textunderscore sort\textunderscore is\textunderscore permutations}}; sendo tais lemas as conjecturas provadas posteriormente pelas questões 2 e 4. 

Apesar dos problemas do trabalho designado serem de relativa simplicidade para alguém especializado na área, estes foram fator determinante para a percepção dos integrantes sobre a importância e abrangência de usos da dedução natural e cálculo sequente, independente do software utilizado para a aplicação da teoria. 
\section*{Referências}



\bibliographystyle{sbc}
\bibliography{./sbc-template}
\cite{ayala}

\end{document}